{"version":3,"sources":["scripts/main.js"],"names":["gameGrid","score","gameOver","win","button","document","querySelector","scoreDisplay","messageStart","messageWin","messageLose","isCellMovable","nextCell","currentCell","startGame","generateInitialCells","addEventListener","handleKeyDown","updateUI","resetGame","classList","add","i","j","generateNewCell","emptyCells","getEmptyCells","length","randomIndex","randomCell","Math","floor","random","newValue","row","col","e","key","moveCellsUp","moveCellsDown","moveCellsLeft","moveCellsRight","moved","newRow","newCol","textContent","cell","cellElement","className","remove","hasAvailableMoves","directions","dx","dy","direction","ni","nj","push","innerText","replace"],"mappings":"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","file":"main.de1db30f.js","sourceRoot":"../src","sourcesContent":["'use strict';\n\n// Game state variables\nlet gameGrid = [];\nlet score = 0;\nlet gameOver = false;\nlet win = false;\n\n// DOM elements\nconst button = document.querySelector('button.button');\nconst scoreDisplay = document.querySelector('.game-score');\nconst messageStart = document.querySelector('.message-start');\nconst messageWin = document.querySelector('.message-win');\nconst messageLose = document.querySelector('.message-lose');\n\nconst isCellMovable = (nextCell, currentCell) => {\n\n  return nextCell === null || nextCell === currentCell;\n};\n\n// Start/Restart game\nfunction startGame() {\n  // Reset game state\n  gameGrid = [];\n  score = 0;\n  gameOver = false;\n  win = false;\n\n  // Generate initial cells\n  generateInitialCells();\n\n  // Set up event listener for keyboard input\n  document.addEventListener('keydown', handleKeyDown);\n\n  // Update UI\n  updateUI();\n}\n\nfunction resetGame() {\n  gameGrid = [];\n  score = 0;\n  gameOver = false;\n  win = false;\n\n  generateInitialCells();\n\n  updateUI();\n\n  // messageStart.classList.remove('hidden');\n  messageLose.classList.add('hidden');\n  messageWin.classList.add('hidden');\n}\n\n// Generate initial cells\nfunction generateInitialCells() {\n  for (let i = 0; i < 4; i++) {\n    gameGrid[i] = [];\n\n    for (let j = 0; j < 4; j++) {\n      gameGrid[i][j] = null;\n    }\n  }\n\n  generateNewCell();\n  generateNewCell();\n}\n\n// Generate new cell (2 or 4)\nfunction generateNewCell() {\n  const emptyCells = getEmptyCells();\n\n  if (emptyCells.length === 0) {\n    // No empty cells, game over\n    gameOver = true;\n\n    return;\n  }\n\n  const randomIndex = Math.floor(Math.random() * emptyCells.length);\n  const randomCell = emptyCells[randomIndex];\n\n  // Randomly choose 2 or 4 with a 10% probability for 4\n  const newValue = Math.random() < 0.9 ? 2 : 4;\n\n  // Update game grid and cell values\n  gameGrid[randomCell.row][randomCell.col] = newValue;\n}\n\n// Handle keyboard input\nfunction handleKeyDown(e) {\n  switch (e.key) {\n    case 'ArrowUp':\n      moveCellsUp();\n      break;\n    case 'ArrowDown':\n      moveCellsDown();\n      break;\n    case 'ArrowLeft':\n      moveCellsLeft();\n      break;\n    case 'ArrowRight':\n      moveCellsRight();\n      break;\n  }\n\n  // Update UI\n  updateUI();\n}\n\n// Move cells up\nfunction moveCellsUp() {\n  let moved = false;\n\n  // Move cells up logic\n  for (let col = 0; col < 4; col++) {\n    for (let row = 1; row < 4; row++) {\n      if (gameGrid[row][col] !== null) {\n        let newRow = row;\n\n        while (newRow > 0) {\n          const nextCell = gameGrid[newRow - 1][col];\n          const currentCell = gameGrid[row][col];\n\n          if (isCellMovable(nextCell, currentCell)) {\n            if (nextCell === currentCell) {\n              // Merge cells\n              gameGrid[newRow - 1][col] *= 2;\n              score += gameGrid[newRow - 1][col];\n              gameGrid[row][col] = null;\n              moved = true;\n\n              if (nextCell === 2048) {\n                win = true;\n              }\n              break;\n            }\n            newRow--;\n          } else {\n            break;\n          }\n        }\n\n        if (newRow !== row) {\n          // Move cell\n          gameGrid[newRow][col] = gameGrid[row][col];\n          gameGrid[row][col] = null;\n          moved = true;\n        }\n      }\n    }\n  }\n\n  if (moved) {\n    generateNewCell();\n    updateUI();\n  }\n}\n\n// Move cells down\nfunction moveCellsDown() {\n  let moved = false;\n\n  // Move cells down logic\n  for (let col = 0; col < 4; col++) {\n    for (let row = 2; row >= 0; row--) {\n      if (gameGrid[row][col] !== null) {\n        let newRow = row;\n\n        while (newRow < 3) {\n          const nextCell = gameGrid[newRow + 1][col];\n          const currentCell = gameGrid[row][col];\n\n          if (isCellMovable(nextCell, currentCell)) {\n            if (nextCell === currentCell) {\n              // Merge cells\n              gameGrid[newRow + 1][col] *= 2;\n              score += gameGrid[newRow + 1][col];\n              gameGrid[row][col] = null;\n              moved = true;\n\n              if (nextCell === 2048) {\n                win = true;\n              }\n              break;\n            }\n            newRow++;\n          } else {\n            break;\n          }\n        }\n\n        if (newRow !== row) {\n          // Move cell\n          gameGrid[newRow][col] = gameGrid[row][col];\n          gameGrid[row][col] = null;\n          moved = true;\n        }\n      }\n    }\n  }\n\n  if (moved) {\n    generateNewCell();\n    updateUI();\n  }\n}\n\n// Move cells left\nfunction moveCellsLeft() {\n  let moved = false;\n\n  // Move cells left logic\n  for (let row = 0; row < 4; row++) {\n    for (let col = 1; col < 4; col++) {\n      if (gameGrid[row][col] !== null) {\n        let newCol = col;\n\n        while (newCol > 0) {\n          const nextCell = gameGrid[row][newCol - 1];\n          const currentCell = gameGrid[row][col];\n\n          if (isCellMovable(nextCell, currentCell)) {\n            if (nextCell === currentCell) {\n              // Merge cells\n              gameGrid[row][newCol - 1] *= 2;\n              score += gameGrid[row][newCol - 1];\n              gameGrid[row][col] = null;\n              moved = true;\n\n              if (nextCell === 2048) {\n                win = true;\n              }\n              break;\n            }\n            newCol--;\n          } else {\n            break;\n          }\n        }\n\n        if (newCol !== col) {\n          // Move cell\n          gameGrid[row][newCol] = gameGrid[row][col];\n          gameGrid[row][col] = null;\n          moved = true;\n        }\n      }\n    }\n  }\n\n  if (moved) {\n    generateNewCell();\n    updateUI();\n  }\n}\n\n// Move cells right\nfunction moveCellsRight() {\n  let moved = false;\n\n  // Move cells right logic\n  for (let row = 0; row < 4; row++) {\n    for (let col = 2; col >= 0; col--) {\n      if (gameGrid[row][col] !== null) {\n        let newCol = col;\n\n        while (newCol < 3) {\n          const nextCell = gameGrid[row][newCol + 1];\n          const currentCell = gameGrid[row][col];\n\n          if (isCellMovable(nextCell, currentCell)) {\n            if (nextCell === currentCell) {\n              // Merge cells\n              gameGrid[row][newCol + 1] *= 2;\n              score += gameGrid[row][newCol + 1];\n              gameGrid[row][col] = null;\n              moved = true;\n\n              if (nextCell === 2048) {\n                win = true;\n              }\n              break;\n            }\n            newCol++;\n          } else {\n            break;\n          }\n        }\n\n        if (newCol !== col) {\n          // Move cell\n          gameGrid[row][newCol] = gameGrid[row][col];\n          gameGrid[row][col] = null;\n          moved = true;\n        }\n      }\n    }\n  }\n\n  if (moved) {\n    generateNewCell();\n    updateUI();\n  }\n}\n\n// Update the UI\nfunction updateUI() {\n  // Update score\n  scoreDisplay.textContent = score;\n\n  // Update cells\n  for (let row = 0; row < 4; row++) {\n    for (let col = 0; col < 4; col++) {\n      const cell = gameGrid[row][col];\n      const cellElement\n        = document.querySelector(`.field-row:nth-child(${row + 1})\n      .field-cell:nth-child(${col + 1})`);\n\n      if (cell === null) {\n        cellElement.textContent = '';\n        cellElement.className = 'field-cell';\n      } else {\n        cellElement.textContent = cell;\n        cellElement.className = `field-cell field-cell--${cell}`;\n      }\n    }\n  }\n\n  // Show win or game over message\n  if (win) {\n    messageWin.classList.remove('hidden');\n  } else if (!hasAvailableMoves()) {\n    messageLose.classList.remove('hidden');\n  }\n}\n\n// Check if there are available moves\nfunction hasAvailableMoves() {\n  // Check if there are empty cells\n  if (getEmptyCells().length > 0) {\n    return true;\n  }\n\n  // Check if any adjacent cells have the same value\n  const directions = [\n    {\n      dx: -1, dy: 0,\n    },\n    {\n      dx: 1, dy: 0,\n    },\n    {\n      dx: 0, dy: -1,\n    },\n    {\n      dx: 0, dy: 1,\n    },\n  ];\n\n  for (let i = 0; i < 4; i++) {\n    for (let j = 0; j < 4; j++) {\n      const currentCell = gameGrid[i][j];\n\n      for (const direction of directions) {\n        const ni = i + direction.dx;\n        const nj = j + direction.dy;\n\n        if (ni >= 0 && ni < 4\n          && nj >= 0 && nj < 4 && gameGrid[ni][nj] === currentCell) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n// Get empty cells\nfunction getEmptyCells() {\n  const emptyCells = [];\n\n  for (let i = 0; i < 4; i++) {\n    for (let j = 0; j < 4; j++) {\n      if (gameGrid[i][j] === null) {\n        emptyCells.push({\n          row: i,\n          col: j,\n        });\n      }\n    }\n  }\n\n  return emptyCells;\n}\n\nbutton.addEventListener('click', (e) => {\n  if (button.innerText === 'Start') {\n    button.classList.replace('start', 'restart');\n    button.innerText = 'Restart';\n    messageStart.classList.add('hidden');\n  } else {\n    resetGame();\n\n    return;\n  }\n\n  startGame();\n});\n"]}